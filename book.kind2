Evenb (n: Nat)              : Bool
Evenb Nat.zero              = Bool.true
Evenb (Nat.succ k)          = Bool.not (Evenb k)

Andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) : Equivalence (Equal (Bool.and b1 b2) Bool.true) (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))
Andb_true_equiv b1 b2 = Equivalence.new (x => Fro_andb_true_equiv b1 b2 x) (y => To_andb_true_equiv b1 b2 y)

To_andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))) : (Equal (Bool.and b1 b2) Bool.true) 
To_andb_true_equiv Bool.true  b2 e = Pair.snd e
To_andb_true_equiv Bool.false b2 e = Pair.fst e

Fro_andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: (Equal (Bool.and b1 b2) Bool.true)) : (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))
Fro_andb_true_equiv Bool.true  b2 e = Pair.new Equal.refl e
Fro_andb_true_equiv Bool.false Bool.true e = 
  let nff   = Equal.apply (x => Bool.not x) e
  Pair.new e (Equal.chain nff e)
Fro_andb_true_equiv Bool.false Bool.false e = Pair.new e e


Orb_true_equiv 
  (b1: Bool) 
  (b2: Bool): Equivalence (Equal (Bool.or b1 b2) Bool.true) (Either (Equal b1 Bool.true) (Equal b2 Bool.true))
Orb_true_equiv b1 b2 = Equivalence.new (x => To_orb_true_equiv b1 b2 x) (y => Fro_orb_true_equiv b1 b2 y)

Fro_orb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: Either (Equal b1 Bool.true) (Equal b2 Bool.true)) : Equal (Bool.or b1 b2) Bool.true
Fro_orb_true_equiv Bool.true b2 e  = Either.lft e
Fro_orb_true_equiv Bool.false b2 e = Either.rgt e

To_orb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: Equal (Bool.or b1 b2) Bool.true) : Either (Equal b1 Bool.true) (Equal b2 Bool.true)
To_orb_true_equiv Bool.true b2 e  = Either.left  (Equal Bool.true Bool.true) (Equal b2 Bool.true) e
To_orb_true_equiv Bool.false b2 e = Either.right (Equal Bool.false Bool.true)(Equal b2 Bool.true) e

Fro_orb_true_equiv1 
  (b1: Bool) 
  (b2: Bool) 
  (e: Equal b1 b2) : Equal (Bool.or b1 b2) Bool.true
Fro_orb_true_equiv1 Bool.true b2          e = Equal.refl
Fro_orb_true_equiv1 Bool.false Bool.true  e = Equal.refl
Fro_orb_true_equiv1 Bool.false Bool.false e = 
  let nff  = Equal.apply (x => Bool.not x) e
  let test2 = (x: (Equal Bool.true Bool.true )) => (Not_implies_our_not x) 
  let test = Not_true_is_false Bool.true test2
  Equal.mirror test



Main {
  Evenb 2n  
}

#axiom
Either.rgt <l> <r> (e: Either l r) : r

#axiom
Either.lft <l> <r> (e: Either l r) : l

True_is_false : Not ( Equal Bool Bool.true Bool.false)
Zero_nbeq_plus_1  (n: Nat)      : (Equal Bool (Nat.equal Nat.zero (Nat.add n (Nat.succ Nat.zero))) Bool.false)
Zero_nbeq_plus_1  Nat.zero      = Equal.refl
Zero_nbeq_plus_1  (Nat.succ n)  = Equal.refl

// True_is_false2 : Equal Bool Bool.true Bool.false
Contradiction_implies_anythig <p> <q> (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app

Not_true_is_false (b: Bool) (h: Not (Equal Bool b Bool.true)) : (Equal Bool b Bool.false)
Not_true_is_false Bool.false h = Equal.refl
Not_true_is_false Bool.true  h = Empty.absurd (h Equal.refl)

Not_implies_our_not1 <p> (e: Not p) : p -> Empty
Not_implies_our_not1 p e = e

Not_implies_our_not <p> (e: p) : Empty
Not_implies_our_not p e =  
  let test  = (x: Not p) => Not_implies_our_not1 p (x)  
  let test1 = Not_implies_our_not test
  test1
  // ?

Confia <x> (e : x -> Type) : Type
