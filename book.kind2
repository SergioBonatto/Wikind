Nat.show (n: Nat) : String {
  (Nat.to_string_base (U60.to_nat 10) n )
}

Plus (n: Nat) (m: Nat)  : Nat
Plus Nat.zero m         = m
Plus (Nat.succ n) m     = Nat.succ (Plus n m)

Example_apply (n: Nat) (m: Nat) (e: Equal m n) : Equal (Nat.succ m) (Nat.succ n)
Example_apply n m e = 
  let e_apply = Equal.apply (x => Nat.succ x) e
  e_apply

Example_case_analysis (b1: Bool)  : Equal (Bool.and b1 Bool.false) Bool.false
Example_case_analysis Bool.true   = Equal.refl
Example_case_analysis Bool.false  = Equal.refl

Plus_id_example (n: Nat) (m: Nat) (e: Equal n m) : Equal (Plus n n) (Plus m m)
Plus_id_example n m e = 
  let app = Equal.apply (x => Plus x n) e
  Equal.rewrite e (x => Equal (Plus n n) (Plus m x)) app 

Problems.t0 (n: Nat) : Equal Nat (Nat.add Nat.zero n) n
Problems.t0 n = Equal.refl

Problems.t1 (n: Nat)      : (Equal Nat (Nat.add n Nat.zero) n)
Problems.t1 Nat.zero      = Equal.refl
Problems.t1 (Nat.succ n)  = 
  let ind = Problems.t1 n  
  let app = Equal.apply (x => (Nat.succ x)) ind
  app

Problems.t2 (n: Nat) (m: Nat) : Equal Nat (Nat.add n (Nat.succ m)) (Nat.succ (Nat.add n m))
Problems.t2 Nat.zero m        = Equal.refl
Problems.t2 (Nat.succ n) m    = 
  let ind = Problems.t2 n m
  let app = Equal.apply (x => (Nat.succ x)) ind
  app

Problems.t3 (n: Nat) (m: Nat) : Equal Nat (Nat.add n m ) (Nat.add m n)
Problems.t3 Nat.zero Nat.zero       = Equal.refl
Problems.t3 Nat.zero (Nat.succ m)   =
  let ind = Problems.t1 m
  let app = Equal.apply (x => Nat.succ x) ind
  Equal.mirror app
Problems.t3 (Nat.succ n) m          = 
  let ind_a = Equal.apply (x => (Nat.succ x)) (Problems.t3 n m)
  let ind_b = Problems.t2 m n
  let ind_c = Equal.chain ind_b (Equal.mirror ind_a)
  let app   = Equal.mirror ind_c
  app


  // (Equal Nat (Nat.succ m) (Nat.succ (Nat.add m 0n)))

Doit3times <x> (f: x -> x) (n: x) : x
Doit3times f n = (f (f ( f n )))

Test_anon_fun : Equal (Doit3times (x => (Nat.mul x x)) (U60.to_nat 2)) (U60.to_nat 256)
Test_anon_fun = Equal.refl

Filter <x> (test: x -> Bool) (xs: List x) : List x
Filter test List.nil  = List.nil
Filter test (List.cons xs.h xs.t) =
  Bool.if (test xs.h) (List.cons xs.h (Filter test xs.t)) (Filter test xs.t)

Length_is_one <x> (xs: List x)  : Bool
Length_is_one xs                = Nat.equal (List.length xs) (Nat.succ Nat.zero)

Test_filter : Equal (Filter (x => (Length_is_one x))([[1], [1, 2], [2], [1, 2, 3], [21]])) ([[1], [2], [21]])
Test_filter = Equal.refl // teste

Filter_even_gt7 (xs: List Nat) : List Nat
Filter_even_gt7  xs = Filter (x => Nat.gtn x 7n) (Filter (y => Nat.is_even y) xs)


Test_filter_even_gt7: Equal (Filter_even_gt7 [1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n]) ([8n, 10n, 12n]) 
Test_filter_even_gt7 = Equal.refl

Test_filter_even_gt7a: Equal (Filter_even_gt7 [5n, 2n, 6n, 19n, 129n]) ([]) 
Test_filter_even_gt7a = Equal.refl

Flat_map <x> <y> (f: x -> List y) (xs: List x)  : List y
Flat_map f List.nil                             = List.nil
Flat_map f (List.cons xs.h xs.t)                = List.concat (f xs.h) (Flat_map f xs.t)

Maybe_map <x> <y> (f: x -> y) (a: Maybe x)  : Maybe y
Maybe_map f Maybe.none                      = Maybe.none
Maybe_map f (Maybe.some x)                  = (Maybe.some (f x))

Fold <x> <y> (f: x -> y -> y) (xs: List x) (a: y) : y
Fold f List.nil a                                 = a
Fold f (List.cons xs.h xs.t) a                    = f xs.h (Fold f xs.t a)

Constfun <y> (x: y) : Nat -> y
Constfun x = y => x 

Ftrue : Nat -> Bool
Ftrue = Constfun Bool.true

Constfun_example1 : Equal ((Ftrue) 0n) Bool.true
Constfun_example1 = Equal.refl

Constfun_example2 : Equal ((Constfun 5n) 99n) 5n
Constfun_example2 = Equal.refl

Plus3 (n: Nat) : Nat
Plus3 n = Plus 3n n

Test_plus3_1 : Equal (Plus3 4n) 7n
Test_plus3_1 = Equal.refl

Test_plus3_2 : Equal (Doit3times (x => Plus3 x) 0n) 9n
Test_plus3_2 = Equal.refl

Test_plus3_3 : Equal (Doit3times (x => Plus 3n x) 0n)9n
Test_plus3_3 = Equal.refl

Fold_length <x> (xs : List x) : Nat
Fold_length xs = Fold  (x => y => Nat.succ y) xs 0n

Test_fold_length1 : Equal (Fold_length [4, 7, 0]) 3n
Test_fold_length1 = Equal.refl

Fold_length_correct <x> (xs: List x): Equal (Fold_length xs) (List.length xs)
Fold_length_correct List.nil = Equal.refl
Fold_length_correct (List.cons xs.h xs.t) = 
  let ind = Fold_length_correct xs.t
  let app = Equal.apply (x => Nat.succ x) ind
  app

Fold_map <a> <b> (f: a -> b) (xs: List a) : List b
Fold_map f List.nil               = List.nil
Fold_map f (List.cons xs.h xs.t)  = List.cons (Fold (x => y => f x) (List.cons xs.h xs.t) (f xs.h)) (Fold_map f xs.t )

Test_fm1 : Equal (Fold_map (x => Nat.add x 3n) [1n, 2n, 3n]) ([4n, 5n, 6n])
Test_fm1 = Equal.refl

Test_fm2 <x> <y> (f: x -> y) (xs: List x) : Equal (Fold_map f xs) (List.map xs f)
Test_fm2 f List.nil               = Equal.refl
Test_fm2 f (List.cons xs.h xs.t)  =
  let ind = Test_fm2 f xs.t
  let app = Equal.apply ( x => (List.cons (f xs.h) x)) ind
  app

Pair_curry <x> <y> <z> (f: (Pair x y) -> z) (x.val: x) (y.val: y) : z
Pair_curry f  x.val y.val = f (Pair.new x.val y.val)

Pair_uncurry <x> <y> <z> (f: x -> y -> z) (p: Pair x y) :  z
Pair_uncurry f (Pair.new x.val y.val)                   = f x.val y.val

Test_map2_1 : Equal (Fold_map (x => Plus 3n x) [2n, 0n, 2n]) [5n, 3n, 5n]
Test_map2_1 = Equal.refl

Uncurry_curry <x> <y> <z> (f: x -> y -> z) (x.val: x) (y.val: y) : Equal (Pair_curry (p => Pair_uncurry f p) x.val y.val) (f x.val y.val)
Uncurry_curry f x y = Equal.refl

Num <x> : Type
Num x   = (x -> x) -> x -> x

One     : Num
One     = s => z => s z

Zero    : Num
Zero    = s => z => z

Two     : Num
Two     = s => z => s (s z)

Three   : Num
Three   = s => z => Doit3times s z

Succ (n: Num) : (Num)
Succ  n       = s => z => s (n s z)

Succ_1  : Equal (Succ Zero) (One)
Succ_1  = Equal.refl

Succ_2  : Equal (Succ One) (Two)
Succ_2  = Equal.refl

Succ_3  : Equal (Succ Two) Three
Succ_3  = Equal.refl


// plus' : (n, m : Nat' {x}) -> Nat' {x}
// plus' n m = ?plus__rhs

// C3+4 = λf . λx . C3 f (C4 f x

Plus_church (n: Num) (m: Num) : Num
Plus_church n m = (s: Num) => (z: Num) => m s (n s z)

Plus_c_1 : Equal (Plus_church Zero One) (One)
Plus_c_1 = Equal.refl

Plus_c_2 : Equal (Plus_church Two Three) (Plus_church Three Two)
Plus_c_2 = Equal.refl

Plus_c_3 : Equal (Plus_church (Plus_church Two Two) Three) (Plus_church One (Plus_church Three Three))
Plus_c_3 = Equal.refl


Mult (n: Num) (m: Num) : Num
Mult n m = (s: Num) => (z: Num) => n (m s) z

Mult_1 : Equal (Mult One One) One
Mult_1 = Equal.refl

Mult_2 : Equal (Mult Zero (Plus_church Three Three)) Zero
Mult_2 = Equal.refl

Mult_3 : Equal (Mult Two Three) (Plus_church Three Three)
Mult_3 = Equal.refl


Exp (n: Num) (m: Num -> Num) : Num 
Exp n m = (s: Num) => (z: Num) => m n s z

Exp1 : Equal (Plus_church (Exp Two Two) One) (Plus_church Two Three)
Exp1 = Equal.refl

Exp2 : Equal (Exp Three Two) (Plus_church (Mult Two (Mult Two Two)) One)
Exp2 = Equal.refl

Exp3 : Equal (Exp Three Zero) One
Exp3 = Equal.refl

Exp4 : Equal (Exp Two Two) (Plus_church Two Two)
Exp4 = Equal.refl


// Pred.aux (n: Num) (m: Num) : Num
// Pred.aux n m = m n

// Pred (n: Num) : Num
// Pred n = Pred.aux n One

// (f => (m => (f (f (f (f (f (f (f (f m))))))))))

// λn λf λx (((n λg λh (h (g f)))λu x) λu u)
// Dec (n: Num)  : Num
// Dec n =
// Dec n = f => x => (n (g => h => h (g f)) (u => x)) (u => u)
// -----------------------------------------------------------
// n => f => x => ((n (g => (u => x) (g f))) (u => u))
// -----------------------------------------------------------
// n => f => x => ((n (g => (u => x) ((u => u) f))))
// -----------------------------------------------------------
// n => f => ((n ((u => u => u) ( f))))
// -----------------------------------------------------------
// n => f => x => ((n (g => h => h (g f)) (u => x)) (u => u))
// -----------------------------------------------------------
//

// Pred1 : Equal (Pred Three) Two
// Pred1 = ?


// CAP 6
// lus_fact : Type
// Plus_fact = 2+2=4

Plus_fact : Type
Plus_fact = Equal (Plus 2n 2n) 4n

// λΠ> :t Plus_fact
// Plus_fact : Type

// lus_fact_is_true : Plus_fact
// plus_fact_is_true = Re
Plus_fact_is_true : Plus_fact 
Plus_fact_is_true = Equal.refl

// is_three : Nat -> Type
// is_three n = n=3
// Is_three (n: Nat) : Nat -> Type
// Is_three n = Equal.refl n 3n

// Injective : (f : a -> b) -> Type

// Injective <a> <b> (f: a -> b) : Type
// Injective {a} {b} f = (x, y : a) -> f x = f y -> x = y
// Injective a b f = (x: a) => (y: a) => (e: Equal (f x) (f y)) => (Equal x y)

// Succ_inj : Injective S
// Succ_inj <a>: Algebra.Laws.injectivity (x => Nat.succ x)
// Succ_inj = x => ?
// succ_inj : Injective S
// Succ_inj = Equal!j

Algebra.Laws.injectivity <a: Type> <b: Type> (f: a -> b) : Type
Algebra.Laws.injectivity a b f = (x: a) -> (y: a) -> (hyp: Equal b (f x) (f y)) -> (Equal a x y)

Nat.succ_injective : Algebra.Laws.injectivity ((n: Nat) => Nat.succ n)
Nat.succ_injective =
  (a: Nat) =>
  (b: Nat) =>
  (hyp: Equal Nat (Nat.succ a) (Nat.succ b)) =>
  Equal.apply (x => Nat.pred x) hyp

type Injective <a: Type> <b: Type> (f: a -> b) {
  new (p: Algebra.Laws.injectivity f)
}

InjectiveNat : Injective (n => Nat.succ n)
InjectiveNat = Injective.new Nat.succ_injective

ConjuntiveBool : Equal Bool (Bool.and Bool.true Bool.false) Bool.false
ConjuntiveBool = Equal.refl

And_example : Pair (Equal (Nat.add 3n 4n) 7n) (Equal (Nat.mul 2n 2n) 4n)
And_example = Pair.new Equal.refl Equal.refl

And_example2 (n: Nat) (m: Nat) (e: Pair (Equal n 0n) (Equal m 0n)) : Equal (Nat.add n m) 0n
And_example2 Nat.zero Nat.zero e      = Equal.refl
And_example2 Nat.zero (Nat.succ m) e  =
  let p = (Equal.rewrite
  (Pair.snd e)
  (x => match Nat x {
    zero => Empty
    succ => Unit 
   })
   (Unit.new))
   Empty.absurd p
And_example2 (Nat.succ n) m e = 
  let p = (Equal.rewrite 
     (Pair.fst e)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

And_example2a (n: Nat) (m: Nat) (e1: Equal n 0n) (e2: Equal m 0n) : Equal (Nat.add n m) 0n
And_example2a Nat.zero Nat.zero e1 e2      = Equal.refl
And_example2a Nat.zero (Nat.succ m) e1 e2  =
  let p = (Equal.rewrite
  (e2)
  (x => match Nat x {
    zero => Empty
    succ => Unit 
   })
   (Unit.new))
   Empty.absurd p
And_example2a (Nat.succ n) m e1 e2  = 
  let p = (Equal.rewrite 
     (e1)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

And_example3 (n: Nat) (m: Nat) (e: Equal (Nat.add n m) 0n) : Equal (Nat.mul n m) 0n
And_example3 Nat.zero m e =  Equal.refl
And_example3 (Nat.succ n) m e =
  let p = (Equal.rewrite 
     (e)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

Proj1 <p> <q> (a: Pair p q) : p
Proj1 (Pair.new fst snd)    = fst

Proj1a <p> <q>  : (Pair p q) -> p
Proj1a p q      = (x: (Pair p q)) => Pair.fst x

Proj2 <p> <q> (b: Pair p q) : q
Proj2 (Pair.new fst snd)    = snd

Proj2a <p> <q>  : (Pair p q) -> q
Proj2a p q      = (x: (Pair p q)) => Pair.snd x

And_commut <p> <q> (c: Pair p q) : Pair q p
And_commut (Pair.new fst snd)    = Pair.new snd fst

And_assoc <p> <q> <r> (a: Pair p (Pair q r))              : Pair (Pair p q) r
And_assoc (Pair.new p (Pair q r) fst (Pair.new snd trd))  = Pair.new (Pair.new fst snd) trd

Or_example (n: Nat) (m: Nat) (e: (Either (Equal n 0n) (Equal m 0n))) : Equal (Nat.mul n m) 0n
Or_example Nat.zero m e     = Equal.refl
Or_example n Nat.zero e     = Mult_0_r n
Or_example (Nat.succ n) m (Either.left l r val) = 
  let p = (Equal.rewrite
    (val)
    (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
    (Unit.new))
  Empty.absurd p
Or_example (Nat.succ n) (Nat.succ m) (Either.right l r val) = 
  let p = (Equal.rewrite 
  (val)
  ( x => match Nat x {
    zero => Empty
    succ => Unit 
    })
    Unit.new)
  Empty.absurd p

#axiom
Or_intro <a> <b> (t: a) : Either a b
Or_intro t              = Either.left t

Pred (n: Nat)     : Nat
Pred Nat.zero     = Nat.zero
Pred (Nat.succ m) = m

Zero_or_succ (n: Nat)     : Either (Equal n Nat.zero) (Equal n (Nat.succ (Pred n)))
Zero_or_succ Nat.zero     = Either.left Equal.refl
Zero_or_succ (Nat.succ m) = Either.right Equal.refl 

#axiom
Mult_eq_0 (n: Nat) (m: Nat) (e: Equal (Nat.mul n m) 0n) : Either (Equal n 0n) (Equal m 0n)
Mult_eq_0 Nat.zero m e = Either.left Equal.refl
Mult_eq_0 n Nat.zero e = Either.right Equal.refl

Or_commut <q> <p> (e: Either p q)         : Either q p
Or_commut q p (Either.left  lft rgt val)  = Either.right rgt lft val
Or_commut q p (Either.right lft rgt val)  = Either.left  rgt lft val

Ex_falso_quodlibet <p>  : Empty -> p
Ex_falso_quodlibet p    = e => Empty.absurd e

// Se `(q -> (p -> q)) = Empty` 
Not_implies_our_not1 <p> (e: Not p) : p -> Empty
Not_implies_our_not1 p e            = e

// Se recebe apenas UM parêmetro 
Not_implies_our_not2 <p> <q> (e: Not p) : q -> (p -> q)
Not_implies_our_not2 p q e              = (x: q) => (y: p) => x

// Se tudo for parâmetro e tetorna só o `q` do final
Not_implies_our_not3 <p> <q> (notp: Not p) (que: q) (pe: p) : q
Not_implies_our_not3 p q notp que pe = que

// zero_not_one = \Refl impossible
Zero_not_one : Not (Equal Nat.zero (Nat.succ Nat.zero))
Zero_not_one = 
  (emp => 
    let app = Equal.apply (x => Nat.is_zero x) emp
    Equal.rewrite app (e => if e {Nat} else {Empty}) Nat.zero)

Not_false : Not Empty
Not_false = e => Empty.absurd e

Contradiction_implies_anythig <p> <q> (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app

Double_neg <p>  : p -> Not (Not p)
Double_neg p    = (x: p) => (y: Not p) => Contradiction_implies_anythig (Pair.new x y)


Contrapositive <p> <q>  : (p -> q) -> ((Not q) -> (Not p))
Contrapositive p q      = (x: p -> q) => (y: Not q) => (z: p) => y (x (z))

// • Expected: ((x_4 : ((x_5 : p) -> q)) -> (x_6 : ((x_1 : q) -> Empty)) -> (x_1 : p) -> Empty)
// • test    : ((x_2 : ((x_3 : p) -> q)) -> (x_1 : ((x_1 : q) -> Empty)) -> (x_3 : p) -> q)

Not_both_true_and_false <p> : Not (Pair p (Not p))
Not_both_true_and_false p   = (x: (Pair p (Not p))) => Contradiction_implies_anythig x
  // let test1 = (x: (Pair p (Not p))) => (Pair.fst x)
  // let test2 = (x: (Pair p (Not p))) => (Pair.snd x)
  // ?

// • Expected: ((x_1 : (Pair p ((x_1 : p) -> Empty))) -> Empty)

Not_true_is_false (b: Bool) (h: Not (Equal Bool b Bool.true)) : (Equal Bool b Bool.false)
Not_true_is_false Bool.false h = Equal.refl
Not_true_is_false Bool.true  h = Empty.absurd (h Equal.refl)

True_is_true : Unit
True_is_true = Unit.new 

// iff : {p,q : Type} -> Type
// iff {p} {q} = (p -> q, q -> p)

record Equivalence (p) (q) {
  lft: p -> q
  rgt: q -> p
}

// iff_sym : (p <-> q) -> (q <-> p)
// iff_sym (pq, qp) = (qp, pq)

Iff_sym <p> <q> (par: Pair (Equivalence p q) (Equivalence q p)) : Pair (Equivalence q p) (Equivalence p q)
Iff_sym p q (Pair.new pq qp) = (Pair.new qp pq)

// not_true_iff_false : (Not (b = True)) <-> (b = False)
// not_true_iff_false {b} = (not_true_is_false b, not_true_and_false b)

// Not_true_iff_false (b: Bool) : Equivalence (Not (Equal Bool b Bool.true)) (Equal b Bool.false)
// Not_true_iff_false b = ?

// not_true_and_false : (b : Bool) -> (b = False) -> Not (b = True)
// not_true_and_false False _ Refl impossible
// not_true_and_false True Refl _ impossible
Not_true_and_false (b: Bool) : 



Main {
  // let c = Filter_even_gt7 b
  let d = [1n, 2n, 3n, 4n]
  let e = Maybe.some (3n)
  // Maybe_map (x => Nat.add 2n x) e
  // let f = Fold (x => y => (+ y x))  b 1
  // f
  // One
  // One
  // Two
  // Three
  // Three
  // Plus_fact
  // Exp Two Three
  // Is_three 2n
  // Fold (x => y => (Bool.and y x)) [Bool.true, Bool.false, Bool.true] Bool.true
  // List.nat_show (Fold (x => y => (List.concat x y)) [[1n], [], [2n, 3n], [], [4n]] [5n, 6n, 7n, 8n])
  // List.nat_show d
  // (x => Nat.show x) c

  // Nat.show (Plus3 3n)
  // List.nat_show (Fold_map (x => Nat.add 3n x) d)
  // Pair_curry (x => (y) => (Pair.new y y))  1n 2n
 Nat.show (Inc 0n)
  
}

List.nat_show (xs: List Nat)        : String
List.nat_show List.nil              = String.nil
List.nat_show (List.cons xs.h xs.t) = 
  (String.concat "[" 
  (String.concat (Nat.show xs.h) 
  (String.concat "," 
  (String.concat (List.nat_show xs.t) "]"))))

Mult_0_r (n: Nat)     : (Equal Nat (Nat.mul n Nat.zero) Nat.zero)
Mult_0_r Nat.zero     = Equal.refl
Mult_0_r (Nat.succ n) = 
  let ind = Mult_0_r n
  let app = Equal.apply (x => (Nat.add x Nat.zero)) ind
  app


Mult_n_m_eq_z (n: Nat) (m: Nat) (e: Equal m 0n)   : (Equal _ (Nat.add (Nat.mul n m) m) 0n)
Mult_n_m_eq_z Nat.zero m e = e
Mult_n_m_eq_z (Nat.succ n) m e = 
  let ind = Mult_n_m_eq_z n m e
  let app = Equal.apply (x => Nat.add x m) ind
  let rwt = Equal.rewrite e (x => (Equal Nat (Nat.add (Nat.add (Nat.mul n m) m) m) x)) app
  rwt

Inc (n: Nat)  : Nat
Inc n         = ((x: Nat) => Nat.succ x) n

Pair_second<a> <b> (e: Pair a b) : b
Pair_second (Pair.new a b) = b

